#/bin/sh
OCAMLC=`which ocamlc`
if [ -z $OCAMLC ]; then
    echo Configuration cannot continue with ocamlc in your PATH
    exit
fi
sed -e '1,/(\* \*)/d' < $0 > configure_tmp.ml
$OCAMLC -w m str.cma unix.cma -impl configure_tmp.ml -o configure_tmp.exe
./configure_tmp.exe "$@"
rm configure_tmp.exe configure_tmp.ml configure_tmp.cmo configure_tmp.cmi
exit
(* *)
module Util : sig
(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)


(** A module with very common operations while configuring *)

(** Executes the given string in a shell, and returns what came through stdout, by
	default clips it at 100 chars, because you are probably just filling in a command
	path - if you don't need the output of the command, use Unix.system or Sys.command.
	If you need all the output, use Unix.open_process_in *)
val shell_capture : ?maxchars:int -> string -> string

(** Chomps off the last character of the string - useful for path manglish sometimes *)
val chomp : string -> string

(** Chomps off the last character only if it matches given char *)
val chomp_char : char -> string -> string

(** Chomps the last character only if it is a trailing \n - convenience wrapper only *)
val chomp_eol : string -> string

(** Escapes all the slashes in a string so it can be used as a regexp *)
val escape_slashes : string -> string

(** Get the extension of a file - the stdlib can chop it off but not return it! *)
val file_extension : string -> string

(** [new_ext file newext] Puts a new extension on a file *)
val new_ext : string -> string -> string

(** Splits a string on whitespace; this is a very common thing to do in order to specify your sources
  in a string rather than a list - save some typing :-) *)
val split : string -> string list

(** Expands all file roots X in a list into X.mli and X.ml so you needn't specify both files
  for each module *)
val both : string list -> string list

(** Prefixes all sources files with a string, presumably something like ["src/"] *)
val prefix : string -> string list -> string list

val join : ?delim:string -> string list -> string
end
= struct
(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)

let prefix pre filelist =
	List.map (fun s -> pre ^ "/" ^ s) filelist

let join ?(delim = " ") l = String.concat delim l

let split s = Str.split (Str.regexp "[ \t\n]+") s;;

let both stems =
    List.flatten (List.map (fun s -> [s ^ ".mli"; s ^ ".ml"]) stems)



let file_ext_index filename =
    let len = String.length filename in
    let reg = Str.regexp "\\." in
    Str.search_backward reg filename (len - 1)

let file_extension filename =
    try
        let len = String.length filename in
        let index = file_ext_index filename in
        String.sub filename (index + 1) (len - index - 1)
    with
        | Not_found -> ""

let new_ext filename ext =
  try
    let index = file_ext_index filename in
    (String.sub filename 0 (index + 1)) ^ ext
  with
    Not_found -> filename ^ "." ^ ext


(* Executes the given string in a shell, and returns what came through stdout *)

let chomp s = String.sub s 0 ((String.length s) - 1)

let chomp_char c s =
    if s.[(String.length s) - 1] = c then
		chomp s
    else
        s

let chomp_eol = chomp_char '\n'

let escape_slashes s =
	Str.global_replace (Str.regexp "/") "\\/" s

(* for now, it uses a stupid temporary file because i'm dumb, and also
clips the stdout crap to 100 chars unless otherwise requested*)
let shell_capture ?(maxchars = 100) command =
	let inchannel = Unix.open_process_in command in
	let buf = String.make maxchars ' ' in

	let len = input inchannel buf 0 maxchars in
	let result = String.sub buf 0 len in

	ignore (Unix.close_process_in inchannel);
	chomp_eol result
end
module CmdLineTools : sig
(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)

(** A very simple module for managing command line tools and their flags *)

(** These are the tools which ocamlconf knows about *)
type tool =
        [
        | `cc
        | `ocamlc
        | `ocamldoc
        | `ocamllex
        | `ocamlmklib
        | `ocamlmktop
        | `ocamlopt
        | `ocamlyacc
        ]

type flags = string list
type command_line = string * flags

(** This is the opaque type which stores a {!command} for each tool *)
type map

(** This map contains the default command line tools, for example [`ocamlc] will
  map to the string ["ocamlc"] *)
val defaultmap : map

(** [replace_command map tool command]
  Returns a map identical to [map] but with the command for [tool] set to [command] *)
val replace_command : map -> tool -> string -> map

(** Adds a single flag to the list for the given tool *)
val add_flag : map -> tool -> string -> map

(** Fetches just the command portion of a tools command_line *)
val command : map -> tool -> string

(** Fetches just the flag portion of a tool's command_line *)
val flags : map -> tool -> string list

(** Gets a string representation, suitable for execution by a shell, of a
  tool's command line *)
val getstring : map -> tool -> string

(** Creates a set of command lines from a list.  Each item in the list is
  pair [tool, flagstring] where the flagstring is naïvely set to the flags
  for the command *)
val map_of_list : (tool * string) list -> map
end
= struct

(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)

open Printf

    type tool = [ `ocamlc | `ocamlmktop | `ocamlopt | `ocamlyacc |
                        `ocamllex | `ocamldoc | `cc | `ocamlmklib ]

    module ToolMap = Map.Make( struct
                                   type t = tool
                                   let compare = Pervasives.compare
                               end )

    type flags = string list

    (* The pair represents the name of the program followed by the list of flags,
        so "ocamlc" can be used as "cc" if you want *)
    type command_line = string * flags

    type map = command_line ToolMap.t

    let defaultmap = List.fold_right (fun (tool,command) map -> ToolMap.add tool (command,[]) map)
        [
            `ocamlc, "ocamlc";
            `ocamlmktop, "ocamlmktop";
            `ocamlopt, "ocamlopt";
            `ocamlyacc, "ocamlyacc";
            `ocamllex, "ocamllex";
            `ocamldoc, "ocamldoc";
            `cc, "ocamlc";
            `ocamlmklib, "ocamlmklib"
        ]
        ToolMap.empty

    let replace_command map tool cmd =
        let (current, flags) = ToolMap.find tool map in
        ToolMap.add tool (cmd, flags) map

    let add_flag map tool flag =
        let (cmd, current) = ToolMap.find tool map in
        ToolMap.add tool (cmd, current @ [flag]) map

    let command map tool = fst (ToolMap.find tool map)
    let flags map tool = snd (ToolMap.find tool map)

    let getstring map tool =
        let (cmd, flags) = ToolMap.find tool map in
        sprintf "%s %s" cmd (String.concat " " flags)

    let map_of_list flags =
        List.fold_left
            (fun map (tool, flagstr) -> add_flag map tool flagstr)
            defaultmap
            flags
end
module Sources : sig

(** A module for managing sets of sources, and manipulating them according to
  their filetypes.*)

(** These are the filetypes that ocamlconf knows about *)
type known_filetype =
  [ `c | `cmi | `cmo | `cmx | `ml | `mli | `mll | `mly | `o | `other ]

(** The type of a set of sources. *)
type t

(** An empty set of sources *)
val empty : t

(** [get sources filetypes] returns a list of the files in sources matching the given
  types.  In the future they will automatically be topologically sorted by dependency,
  but that code has not been integrated. *)
val get : t -> known_filetype list -> string list

(** [all sources] simply returns every source file in the set of sources *)
val all : t -> string list

(** [add_by_extension sources file] will add the file to the set of sources.  It will
  detect its filetype by its extension, and will also automatically add all byproducts this
  file will create *)
val add_by_extension : t -> string -> t

(** From a list of files, creates a set of sources.  *)
val of_list : string list -> t
end
= struct

(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)


type known_filetype = [ `mli | `ml | `mll | `mly | `c | `cmi | `cmo | `cmx | `o | `other ]

module SourceMap = Map.Make( struct
                                 type t = known_filetype
                                 let compare = Pervasives.compare
                             end )

type t = (string list) SourceMap.t

let empty = SourceMap.empty

(* Returns a list of all the types of sources specified, in the order they
    are specified.  TODO: topological sort based on dependencies *)
let get sources desired_types =
    SourceMap.fold
        (fun sourcetype sourcelist all_list ->
             if List.mem sourcetype desired_types then
                 all_list @ sourcelist
             else
                 all_list)
        sources
        []

let all sources =
    SourceMap.fold
        (fun sourcetype sourcelist all_list -> all_list @ sourcelist)
        sources
        []


let append sources filemappings =
    List.fold_left
        (fun sources (sourcetype, newfiles) ->
             let curr = get sources [sourcetype] in
             SourceMap.add sourcetype (curr @ newfiles) sources)
        sources
        filemappings

open Util
let add_by_extension sources file =
    match file_extension file with
		| "mli" ->
              append sources [
                  `mli, [file];
                  `cmi, [new_ext file "cmi"]
              ]

        | "ml" ->
              append sources [
                  `ml, [file];
                  `cmi, [new_ext file "cmi"];
				  `cmo, [new_ext file "cmo"];
				  `cmx, [new_ext file "cmx"];
				  `other, [new_ext file "o"]
              ]

        | "c" ->
              append sources [
                  `c, [file];
                  `o, [new_ext file "o"]
              ]

        | "mll" ->
              append sources [
                  `mll, [file];
				  `ml, [new_ext file "ml"];
				  `cmi, [new_ext file "cmi"];
				  `cmo, [new_ext file "cmo"];
				  `cmx, [new_ext file "cmx"];
				  `other, [new_ext file "o"]
              ]

		| "mly" ->
              append sources [
                  `mly, [file];
				  `ml, [new_ext file "ml"];
				  `mli, [new_ext file "mli"];
				  `cmi, [new_ext file "cmi"];
				  `cmo, [new_ext file "cmo"];
				  `cmx, [new_ext file "cmx"];
				  `other, [new_ext file "o"]
              ]

        | _ -> sources

let of_list files =
    List.fold_left add_by_extension empty files


end
module Libs : sig

(** A nearly trivial module for managing libs that are not findlib-enabled *)

(** The type of libraries.  They are merely two names for byte code and native code *)
type t = { cmxa : string list; cma : string list; }

(** The empty set of libraries *)
val empty : t

(** Add a library by name.  The name must not contain an extension - these will be
  added automatically depending on whether byte code or native code is chosen *)
val add : t -> string -> t

(** From a list of non-suffixed names of libraries, create a set of libs *)
val of_list : string list -> t
end
= struct

(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)


type t = {
    cmxa : string list;
    cma : string list
}

let empty = {
	cmxa = [];
    cma = [];
}


let add libs libname =
  { cma = libs.cma @ [libname ^ ".cma"];
    cmxa = libs.cmxa @ [libname ^ ".cmxa"] }

let of_list libs =
    List.fold_left add empty libs
end
module Product : sig
(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)

class virtual base : string -> object method name : string end

(** Where/how to install the target *)
type destination =
        [
        | `bin				(** Defaults to /usr/local/bin *)
        | `lib				(** Defaults to /usr/local/lib/ocaml/packagename - incomplete *)
        | `findlib			(** Uses findlib to install all appropriate files *)
        | `nowhere			(** Is not installed *)
        | `other of string	(** A literal directory to install the file to?? *)
        ]

class virtual sourced :
    ?source_filetypes:Sources.known_filetype list ->
    ?cleaned_filetypes:Sources.known_filetype list ->
    sources:Sources.t ->
    string ->
object
    method cleaned : string list
    method name : string
    method sources : string list
    method has_c_sources : bool
end

class virtual caml :
    sources:Sources.t ->
    ?libs:Libs.t ->
    string ->
object
    method byte_libs : string list
    method byte_objects : string list
    method obj_objects : string list
    method cleaned : string list
    method interfaces : string list
    method name : string
    method sources : string list
    method has_c_sources : bool
end

class virtual opt_caml :
    sources:Sources.t ->
    ?libs:Libs.t ->
    string ->
object
    method byte_libs : string list
    method byte_objects : string list
    method obj_objects : string list
    method cleaned : string list
    method interfaces : string list
    method name : string
    method opt_libs : string list
    method opt_objects : string list
    method sources : string list
    method has_c_sources : bool
end

class virtual ocamlfind :
    findlibs:string list ->
    string ->
object
    method findlibs : string list
    method name : string
end

class virtual installed :
    dest:destination ->
    string ->
object
    method destination : destination
    method name : string
end

class script :
    ?dest:destination ->
    string ->
object
    method name : string
    method destination : destination
end

class executable :
    ?sources:Sources.t ->
    ?findlibs:string list ->
    ?libs:Libs.t ->
    ?dest:destination ->
    string ->
object
    method byte_libs : string list
    method byte_objects : string list
    method obj_objects : string list
    method destination : destination
    method cleaned : string list
    method findlibs : string list
    method interfaces : string list
    method name : string
    method opt_libs : string list
    method opt_name : string
    method opt_objects : string list
    method sources : string list
    method has_c_sources : bool
end

class toplevel :
    ?sources:Sources.t ->
    ?findlibs:string list ->
    ?libs:Libs.t ->
    ?dest:destination ->
    string ->
object
    method byte_libs : string list
    method destination : destination
    method byte_objects : string list
    method obj_objects : string list
    method cleaned : string list
    method findlibs : string list
    method interfaces : string list
    method name : string
    method sources : string list
    method has_c_sources : bool
end

class documentation :
    ?findlibs:string list ->
    ?sources:Sources.t ->
    ?dest:destination ->
    string ->
object
    method cleaned : string list
    method destination : destination
    method dot_file : string
    method findlibs : string list
    method html_dir : string
    method latex_file : string
    method man_dir : string
    method name : string
    method sources : string list
    method texi_file : string
    method has_c_sources : bool
end

class library :
    ?shared:bool ->
    ?sources:Sources.t ->
    ?findlibs:string list ->
    ?libs:Libs.t ->
    ?dest:destination ->
    string ->
object
    method byte_libs : string list
    method destination : destination
    method byte_objects : string list
    method obj_objects : string list
    method c_a_name : string
    method c_so_name : string
    method cleaned : string list
    method cma_name : string
    method cmxa_a_name : string
    method cmxa_name : string
    method findlibs : string list
    method interfaces : string list
    method name : string
    method opt_libs : string list
    method opt_objects : string list
    method sources : string list
    method has_c_sources : bool
    method shared : bool

    method cma_c_deps : string list
    method cmxa_c_deps : string list
end
end
= struct

(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)


open Printf;;
open Util

type destination = [`bin | `lib | `findlib | `nowhere | `other of string]

(* A general superclass for all targets *)
class virtual base name = object(self)
    method name : string = name
end


(* Some convenient mixin-classes *)
class virtual sourced
    ?(source_filetypes = [`mli; `ml; `c])
    ?(cleaned_filetypes = [`cmi; `cmo; `cmx; `o; `other])
    ~sources
    name
    =
object(self)
    inherit base name

    method has_c_sources = Sources.get sources [`c] <> []
    method sources = Sources.get sources source_filetypes
    method cleaned = Sources.get sources cleaned_filetypes
end

class virtual caml
    ~sources
    ?(libs = Libs.empty)
    name
    =
object(self)
    inherit sourced ~sources name as super

    method interfaces = Sources.get sources [`cmi]
    method byte_objects = Sources.get sources [`cmo]
    method obj_objects = Sources.get sources [`o]
    method byte_libs = libs.Libs.cma
end

class virtual opt_caml
    ~sources
    ?(libs = Libs.empty)
    name
    =
object(self)
    inherit caml ~sources ~libs name as super

    method opt_objects = Sources.get sources [`cmx]
    method opt_libs = libs.Libs.cmxa
end


class virtual ocamlfind
    ~findlibs
    name
    =
object(self)
    inherit base name

    method findlibs : string list = findlibs
end

class virtual installed
    ~(dest : destination)
    name
    =
object(self)
    inherit base name
    method destination = dest
end

class script
    ?(dest = `bin)
    name
    =
object(self)
    inherit base name
    inherit installed ~dest name
end

class executable
    ?(sources = Sources.empty)
    ?(findlibs = [])
    ?(libs = Libs.empty)
    ?(dest = `bin)
	name
    =
object(self)
    inherit base name as super
    inherit opt_caml ~sources ~libs name
    inherit ocamlfind name ~findlibs
    inherit installed ~dest name

    method opt_name = name ^ ".opt"
end

class toplevel
    ?(sources = Sources.empty)
    ?(findlibs = [])
    ?(libs = Libs.empty)
    ?(dest = `nowhere)
	name
    =
object(self)
    inherit base name as super
    inherit caml name ~sources ~libs as caml
    inherit ocamlfind name ~findlibs as ocamlfind
    inherit installed ~dest name
end

class documentation
    ?(findlibs = [])
    ?(sources = Sources.empty)
    ?(dest = `nowhere)
    name
    =
object(self)
    inherit ocamlfind ~findlibs name as ocamlfind
    inherit sourced
        ~source_filetypes:[`mli; `ml]
        ~cleaned_filetypes:[]
        ~sources
        name as sourced
    inherit installed ~dest name

    method html_dir = name ^ ".html"
    method man_dir = name ^ ".man"
    method texi_file = name ^ ".texi"
    method dot_file = name ^ ".dot"
    method latex_file = name ^ ".text"

end

class library
    ?(shared = false)
	?(sources = Sources.empty)
	?(findlibs = [])
	?(libs = Libs.empty)
    ?(dest = `findlib)
	name
    =
object(self)
    inherit base name as super
    inherit opt_caml ~sources ~libs name as caml
    inherit ocamlfind ~findlibs name as ocamlfind
    inherit installed ~dest name

    method cma_name = name ^ ".cma"
    method cmxa_name = name ^ ".cmxa"
    method cmxa_a_name = name ^ ".a"
    method c_a_name = "lib" ^ name ^ ".a"
    method c_so_name = "dll" ^ name ^ ".so"
    method has_c_sources = ([] <> Sources.get sources [`c])
    method shared = shared

    method cma_c_deps =
        match self # has_c_sources, shared with
            | false, _ -> []
            | true, false -> [self # c_a_name]
            | true, true -> [self # c_a_name; self # c_so_name]

    method cmxa_c_deps = if self # has_c_sources then [self # c_a_name] else []
end
end
module Package : sig


(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)

(** A module for carrying around all the metadata needed to build a whole package. *)

(** A tagged variant of the product types, so we can utilize their specialization later *)
type product =
        [ `documentation of Product.documentation
        | `executable of Product.executable
        | `library of Product.library
        | `script of Product.script
        | `toplevel of Product.toplevel ]


(** The type of packages *)
type t = {
    package : string;
    version : string;
    findlib_package : string;
    cleaned : string list;
    debug : bool;
    destdir : string;
    prefix : string;
    sources : Sources.t;
    findlibs : string list;
    libs : Libs.t;
    includes : string list;
    findlib_installed_files : string list;
    findlib_installs_opt : bool;
    command_line : CmdLineTools.map;
    products : product list;
}

val create :
    ?package:string ->
    ?version:string ->
    ?findlib_package:string ->
    ?cleaned:string list ->
    ?destdir:string ->
    ?debug:bool ->
    ?prefix:string ->
    ?sources:Sources.t ->
    ?findlibs:string list ->
    ?libs:Libs.t ->
    ?includes:string list ->
    ?findlib_installed_files:string list ->
    ?findlib_installs_opt:bool ->
    ?command_line:CmdLineTools.map -> product list -> t

(** {6 Shortcuts for Product creation} *)

(** A shortcut function for creating a {!Product.library} and tagging it. *)
val library :
    ?dest:Product.destination ->
    ?shared:bool ->
    ?sources:Sources.t ->
    ?findlibs:string list ->
    ?libs:Libs.t -> string -> [> `library of Product.library ]

(** See {!Package.library} *)
val executable :
    ?sources:Sources.t ->
    ?findlibs:string list ->
    ?libs:Libs.t ->
    ?dest:Product.destination ->
    string -> [> `executable of Product.executable ]

(** See {!Package.library} *)
val script :
    ?dest:Product.destination -> string -> [> `script of Product.script ]

(** See {!Package.library} *)
val toplevel :
    ?sources:Sources.t ->
    ?findlibs:'a ->
    ?libs:Libs.t ->
    ?dest:Product.destination ->
    ?findlibs:string list -> string -> [> `toplevel of Product.toplevel ]

(** See {!Package.library} *)
val documentation :
    ?findlibs:string list ->
    ?sources:Sources.t ->
    string -> [> `documentation of Product.documentation ]

end
= struct

(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)

type product =
        [
        | `executable of Product.executable
        | `library of Product.library
        | `documentation of Product.documentation
        | `script of Product.script
        | `toplevel of Product.toplevel
        ]

let library ?dest ?shared ?sources ?findlibs ?libs name =
    `library (new Product.library ?dest ?shared ?sources ?findlibs ?libs name)

let executable ?sources ?findlibs ?libs ?dest name =
    `executable (new Product.executable ?sources ?findlibs ?libs ?dest name)

let script ?dest name =
    `script (new Product.script ?dest name)

let toplevel ?sources ?findlibs ?libs ?dest ?findlibs name =
    `toplevel (new Product.toplevel ?sources ?findlibs ?libs ?dest name)

let documentation ?findlibs ?sources name =
    `documentation (new Product.documentation ?findlibs ?sources name)


type t = {
	package : string;
    version : string;
    findlib_package : string;
    cleaned : string list;
    debug : bool;
    destdir : string;
	prefix : string;
    sources : Sources.t;
    findlibs : string list;
    libs : Libs.t;
    includes : string list;
    findlib_installed_files : string list;
    findlib_installs_opt : bool;
    command_line : CmdLineTools.map;
    products : product list
}

let create
	?(package = "")
    ?(version = "")
    ?(findlib_package = package)
    ?(cleaned = [])
    ?(destdir = "")
    ?(debug = false)
	?(prefix = "/usr/local")
	?(sources = Sources.empty)
	?(findlibs = [])
	?(libs = Libs.empty)
	?(includes = [])
	?(findlib_installed_files = [])
	?(findlib_installs_opt = true)
	?(command_line = CmdLineTools.defaultmap)
    products
    =
    {
        package = package;
        findlib_package = findlib_package;
        version = version;
        cleaned = cleaned;
        destdir = destdir;
        debug = debug;
	    prefix = prefix;
	    sources = sources;
	    findlibs = findlibs;
	    libs = libs;
	    includes = includes;
	    findlib_installed_files = findlib_installed_files;
	    findlib_installs_opt = findlib_installs_opt;
	    command_line = command_line;
        products = products
    }
end
module AutoMake : sig
(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)


(** A module for generating makefiles for ocaml projects.  It mostly contains shortcut
  functions in {!Product} and {!Package} modules.


  The important targets provided by the generated makefile are:
  all, byte, opt, doc, install, install-opt, clean, distclean, tar, bzip2, gzip

  Planned targets: rpm, deb *)

(** The opaque type of a makefile 'target' containing all its metadata.  All targets
    either handle C code properly or ignore it if appropriate (such as for documentation) *)

(** {6 Shortcuts} *)

(** Every value here is a "shortcut" for the functions in the {!Package} module, which
  in turn are shortcuts for items in the {!Product} module.  These all parse your lists of
  strings, though, so you will probably prefer these. *)
val library :
    ?sources:string list ->
    ?libs:string list ->
    ?findlibs:string list ->
    ?shared:bool ->
    ?dest:Product.destination ->
    string ->
    Package.product

(** See {!AutoMake.library} *)
val executable :
    ?sources:string list ->
    ?libs:string list ->
    ?findlibs:string list ->
    ?dest:Product.destination ->
    string ->
    Package.product

(** See {!AutoMake.library} *)
val toplevel :
    ?sources:string list ->
    ?libs:string list ->
    ?findlibs:string list ->
    ?dest:Product.destination ->
    string ->
    Package.product

(** See {!AutoMake.library} *)
val documentation :
    ?sources:string list ->
    ?findlibs:string list ->
    string ->
    Package.product

(** See {!AutoMake.library} *)
val script :
    ?dest:Product.destination ->
    string ->
    Package.product


(** Creates a package that is ready for automaking.  This is a shortcut for {!Package.create},
  pretty much.  I leave it here because it is very concise (and I already wrote it before the
  [Package] module even existed *)

val package :
	?package : string ->
    ?version : string ->
    ?destdir : string ->
    ?prefix : string ->
    ?sources : string list ->
    ?findlibs : string list ->
    ?libs : string list ->
    ?includes : string list ->
    ?findlib_package : string ->
    ?findlib_installed_files : string list ->
    ?findlib_installs_opt : bool ->
    ?flags : (CmdLineTools.tool * string) list ->
    ?cleaned : string list ->
	?debug:bool ->
	Package.product list ->
    Package.t

(** {6 Automatically generating a makefile} *)

(** Outputs a makefile for any {!Package.t} *)
val output_makefile : ?filename : string -> Package.t -> unit
(*val output_meta : ?filename : string -> autopackage -> unit
val output_ebuild : ?filename : string -> autopackage -> unit
val output_omakefile : ?filename : string -> autopackage -> unit*)

(** {6 Deprecated main function} *)

(** This function is exactly [AutoMake.output_makefile (AutoMake.autopackage ...)] *)
val output :
	?package : string ->
    ?version : string ->
    ?destdir : string ->
    ?prefix : string ->
    ?sources : string list ->
    ?findlibs : string list ->
    ?libs : string list ->
    ?includes : string list ->
    ?findlib_package : string ->
    ?findlib_installed_files : string list ->
    ?findlib_installs_opt : bool ->
    ?flags : (CmdLineTools.tool * string) list ->
    ?cleaned : string list ->
	?debug:bool ->
	Package.product list ->
    unit

end
= struct

(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)


open Printf;;

module Makefile = struct
    (* A simple representation of our makefile - we will use no extended features *)
    type var = string * string (* name, value *)
    type rule = string * string * string (* name, deps, action *)
    type makefile = (var list) * (rule list)


    let max_width = 60

    let indent indentation str =
        (Str.global_replace (Str.regexp "^") indentation (Util.chomp_eol str)) ^ "\n"

    let rec pretty_concat ?(width = 80) ?(len = 0) ?(str = "") filelist =
	    match filelist with
	        | [] -> str
	        | file::rest ->
		          if len > width then
			          pretty_concat ~len:(String.length file) ~width ~str:(str ^ "\\\n\t" ^ file ^ " ") rest
		          else
			          pretty_concat ~len:(len + (String.length file)) ~width ~str:(str ^ file ^ " ") rest

    let pretty_varvalue name value =
	    if name = "" then sprintf "%s\n" value else (
	        if (String.length name) + (String.length value) + 3 > max_width then
		        sprintf "%s = \\\n\t%s\n"
			        name
			        (pretty_concat ~width:max_width (Str.split (Str.regexp "[ \t\n]+") value))
	        else
		        sprintf "%s = %s\n" name value )

    let render ?(channel = stdout) vars deps =
	    List.iter
		    (fun (name,value) -> output_string channel (pretty_varvalue name value))
		    vars;

	    output_string channel "\n";

	    List.iter
		    (fun (name,deps,action) ->
                 if name <> "" then
			         fprintf channel
                         "%s: %s\n%s\n" name deps (if action <> "" then indent "\t" action else ""))

		    deps

end

module Install = struct

    let dest_dir = function
	    | `bin -> "$(PREFIX_DESTDIR)/bin"
	    | `lib -> "$(PREFIX_DESTDIR)lib"
        | `other s -> s
	    | `nowhere
        | `findlib -> raise (Invalid_argument "dest_dir")

    let ensure_dir dest =
        sprintf "install -d %s" dest

    let install ~dest ~mode name =
        let destination = dest_dir dest in
        (ensure_dir destination) ^ "\n" ^
	    sprintf "install -m %i %s %s/%s" mode name destination name

    let uninstall ~dest name =
        let destination = dest_dir dest in
        sprintf "rm -f %s/%s" destination name

end



type global_target = [ `all | `opt | `byte | `doc | `top | `dep |
                           `clean | `install | `install_opt | `uninstall | `findlib]

class type make_builder = object
    method globals : global_target -> string list
    method vars : Makefile.var list
    method rules : Makefile.rule list
end




(* This module pretty much contains a bunch of classes that inherit from the
   global Product modules *)

open Util

let variable product name value = sprintf "%s_%s" product#name name, value

let source_vars product = [variable product "SOURCES" (join (product # sources))]

let byte_vars product =
    [
		variable product "OBJECTS" (join (product # byte_objects));
        variable product "LIBS" (join (product # byte_libs));
		variable product "O_OBJECTS" (join (product # obj_objects));
    ]

let opt_vars product =
    [
        variable product "OPT_OBJECTS" (join (product # opt_objects));
        variable product "OPT_LIBS" (join (product # opt_libs));
    ]

let findlib_vars product = [variable product "FINDLIBS" (join (product # findlibs))]

class installer
    ?(findlib_installs_opt = false)
    ?(install_opt_name : string option)
    ?(opt = [])
    ?(byte = [])
    ~dest
    install_name
    =
    let uninstall_name = "un" ^ install_name in
    let opt_names = List.map fst opt in
    let byte_names = List.map fst byte in
object(self)
    method globals (which : global_target) =
        if dest = `nowhere then
            []
        else
            match which with
                | `install -> if dest <> `findlib then [install_name] else []

                | `install_opt ->
                      (match dest, install_opt_name with
                           | _, None
                           | `findlib, _ -> []
                           | _, Some s -> [s])

                | `uninstall ->  (* Almost an "if" but it could expand *)
                      (match dest, install_opt_name with
                           | `findlib, _ -> []
                           | _, _ -> [uninstall_name])

                | `findlib ->
                      (match dest, findlib_installs_opt with
                           | `findlib, false -> byte_names
                           | `findlib, true -> byte_names @ opt_names
                           | _, _ -> [])

                | _ -> failwith "Invalid global passed to installer"

    method rules =
        let install_rule (file, mode) = Install.install ~dest ~mode file in
        let uninstall_rule (file,_) = Install.uninstall ~dest file in

        match dest with
            | `nowhere | `findlib -> []
            | _ ->
                  [
                      install_name,
                      join byte_names,
                      join ~delim:"\n" (List.map install_rule byte)
                  ]
                  @
                  [
                      (uninstall_name,
                       "",
                       join ~delim:"\n" (List.map uninstall_rule (byte @ opt)))
                  ]
                  @
                  (match install_opt_name with
                       | None -> []
                       | Some opt_install ->
                             [
                                 opt_install,
                                 join opt_names,
                                 join ~delim:"\n" (List.map install_rule opt)
                             ])

end

class script_builder script =
    let installer = new installer
                        ~dest:(script # destination)
                        ~byte:[script # name, 755]
                        ("install-" ^ script # name)
    in
object(self)
    method globals (which : global_target) =
        match which with
            | `install | `uninstall | `findlib | `install_opt -> installer # globals which

            | _ -> []

    method vars = ([] : Makefile.var list)
    method rules = installer # rules
end


class executable_builder executable =
    let installer =
        new installer
            ~dest:(executable # destination)
            ~install_opt_name:("install-" ^ executable # opt_name)
            ~opt:[executable # opt_name, 755]
            ~byte:[executable # name, 755]
            ("install-" ^ executable # name)
    in
object(self)
    method globals (which : global_target)=
        match which with
            | `install
            | `install_opt
            | `uninstall
            | `findlib -> installer # globals which

            | `dep -> executable # sources
            | `all | `byte -> [executable # name]
            | `opt -> [executable # opt_name]

            | `clean ->
                  [executable # name;
                   executable # opt_name]
                  @ (executable # cleaned)

            | `doc | `top -> []

    method vars = (source_vars executable) @ (byte_vars executable)
                  @ (opt_vars executable) @ (findlib_vars executable)

    method rules =
        let name = executable # name in
        [
		    (name,
             sprintf "$(OBJECTS) $(O_OBJECTS) $(%s_OBJECTS) $(%s_O_OBJECTS)" name name,
			 sprintf "$(LINK) $(%s_FINDLIBS) $(%s_LIBS) -o $@ $(O_OBJECTS) \
                                  $(OBJECTS) $(%s_O_OBJECTS) $(%s_OBJECTS)"
				 name name name name);

		    (executable # opt_name,
             sprintf "$(OPT_OBJECTS) $(O_OBJECTS) $(%s_OPT_OBJECTS) $(%s_O_OBJECTS)" name name,
			 sprintf "$(LINK_OPT) $(%s_FINDLIBS) $(%s_OPT_LIBS) -o $@ \
                            $(O_OBJECTS) $(OPT_OBJECTS) $(%s_O_OBJECTS) $(%s_OPT_OBJECTS)"
				 name name name name);
        ]
        @
        (installer # rules)

end

class toplevel_builder toplevel =
    let installer = new installer
                        ~dest:(toplevel # destination)
                        ~byte:[toplevel # name, 755]
                        ("install-" ^ toplevel # name)
    in
object(self)
    method globals (which : global_target) =
        match which with
            | `findlib | `install_opt | `install | `uninstall -> installer # globals which

            | `dep -> toplevel # sources
            | `top -> [toplevel # name]
            | `clean -> [toplevel # name] @ (toplevel # cleaned)
            | `all | `opt | `byte | `doc -> []

    method vars = (byte_vars toplevel) @ (findlib_vars toplevel) @ (source_vars toplevel)

    method rules =
        let name = toplevel # name in
        [
		    (name,
             sprintf "$(OBJECTS) $(O_OBJECTS) $(%s_OBJECTS) $(%s_O_OBJECTS)" name name,
			 sprintf "$(MKTOP) $(%s_FINDLIBS) $(%s_LIBS) -o $@ $(OBJECTS) \
                                  $(O_OBJECTS) $(%s_OBJECTS) $(%s_O_OBJECTS)"
				 name name name name);
        ]
        @
        (installer # rules)

end

class documentation_builder docs =
object(self)
    method globals (which : global_target) =
        match which with
            | `dep -> docs # sources
            | `doc -> [docs # name ^ ".html"]
            | `clean -> []
            | `opt | `all | `byte | `top | `install | `uninstall | `findlib | `install_opt -> []

    method vars = (source_vars docs) @ (findlib_vars docs)

    method rules =
        List.map
            (fun (needs_dir, flags, suffix) ->
                 let name = docs # name in
                 let docname = name ^ suffix in
                 let mkdir = if needs_dir then sprintf "mkdir -p %s &&" docname else "" in
                 let cmd = sprintf "$(DOC) $(%s_FINDLIBS) %s%s" name flags docname in
			     (docname,
                  sprintf "$(SOURCES) $(%s_SOURCES)" name,
			      sprintf "%s %s $(SOURCES) $(%s_SOURCES)"
				      mkdir cmd name ))
            [
                true, "-html -d ", ".html";
                true, "-man -d ", ".man";
                false, "-texi -o ", ".texi";
                false, "-dot -o ", ".dot";
                false, "-latex -o ", ".tex";
            ]
end

class library_builder library =
    (* hack alert *)
    let c_a_rule =
        (library # c_a_name,
         sprintf "$(O_OBJECTS) $(%s_O_OBJECTS)" library # name,
         sprintf "$(LINKLIB_STATIC) $@ $(O_OBJECTS) $(%s_O_OBJECTS)" library # name) in

    let c_so_rule =
        (library # c_so_name,
         sprintf "$(O_OBJECTS) $(%s_O_OBJECTS)" library # name,
         sprintf "$(LINKLIB_SHARED) -o $@ $(O_OBJECTS) $(%s_O_OBJECTS)" library # name) in

    let cma_install, cmxa_install, cmxa_a_install, c_a_install, c_so_install =
        (library # cma_name, 644),
        (library # cmxa_name, 644),
        (library # cmxa_a_name, 755),
        (library # c_a_name, 755),
        (library # c_so_name, 755)
    in

    let installer = new installer
                        ~dest:(library # destination)
                        ~install_opt_name:("install-" ^ library # cmxa_name)
                        ~byte:(match library # has_c_sources, library # shared with
                                   | false, _ -> [cma_install]
                                   | true, false -> [cma_install; c_a_install]
                                   | true, true -> [cma_install; c_a_install; c_so_install])
                        ~opt:(if library # has_c_sources then
                                  [cmxa_install; cmxa_a_install; c_a_install]
                              else
                                  [cmxa_install; cmxa_a_install])
                        ("install-" ^ library # cma_name)
    in
    let name = library # name in
object(self)

    method c_vars =
        [
            variable library "C_STATIC_LIBS" (sprintf "-cclib -l%s" name);
            variable library "C_SHARED_LIBS" (sprintf "-cclib -l%s -dllib -l%s" name name);
        ]


    val cma_rule =
        let cma_c_flags =
            match library # has_c_sources, library # shared with
                | false, _ -> ""
                | true, false -> sprintf " $(%s_C_STATIC_LIBS)" name
                | true, true -> sprintf " $(%s_C_SHARED_LIBS)" name
        in
		(library # cma_name,
         sprintf "$(OBJECTS) $(%s_OBJECTS) %s" library#name (join library#cma_c_deps),
		 sprintf "$(LINKLIB) $(%s_FINDLIBS) %s $(%s_LIBS) -o $@ \
                              $(OBJECTS) $(%s_OBJECTS)"
			 name cma_c_flags name name)

    val cmxa_rule =
        let cmxa_c_flags =
            if library # has_c_sources then sprintf "$(%s_C_STATIC_LIBS)" name else ""
        in
        (library # cmxa_name,
         sprintf "$(OPT_OBJECTS) $(%s_OPT_OBJECTS) %s" name (join library#cmxa_c_deps),
		 sprintf "$(LINKLIB_OPT) $(%s_FINDLIBS) %s $(%s_OPT_LIBS) -o $@ \
                            $(OPT_OBJECTS) $(%s_OPT_OBJECTS)"
			 name cmxa_c_flags name name)

    method globals (which : global_target) : string list =
        match which with
            | `install | `install_opt | `findlib | `uninstall -> installer # globals which

            | `dep -> library # sources
            | `all -> [library # cma_name]
            | `opt -> [library # cmxa_name]
            | `byte -> [library # cma_name]
            | `clean -> [library # cma_name;
                         library # cmxa_name;
                         library # cmxa_a_name;
                         library # c_so_name;
                         library # c_a_name] @ (library # cleaned)

            | `doc | `top -> []

    method vars =
        (source_vars library) @ (byte_vars library) @ (opt_vars library) @ (findlib_vars library) @
        (if library # has_c_sources then self # c_vars else [])

    method rules =
        (match library # has_c_sources, library # shared with
             | false, _ -> [cma_rule; cmxa_rule]
             | true, false -> [cma_rule; cmxa_rule; c_a_rule]
             | true, true -> [cma_rule; cmxa_rule; c_a_rule; c_so_rule])
        @
        (installer # rules)
end



(* * * Makefile Variables * * *)

(* Really snappy wrappers *)
let library ?(sources = []) ?(libs = []) ?findlibs ?shared ?dest name =
    Package.library
        ~sources:(Sources.of_list sources)
        ~libs:(Libs.of_list libs)
        ?findlibs
        ?shared
        ?dest
        name

let executable ?(sources = []) ?(libs = []) ?findlibs ?dest name =
    Package.executable
        ~sources:(Sources.of_list sources)
        ~libs:(Libs.of_list libs)
        ?findlibs
        ?dest
        name

let script ?dest name =
    Package.script
        ?dest
        name

let toplevel ?(sources = []) ?(libs = []) ?findlibs ?dest name =
    Package.toplevel
        ~sources:(Sources.of_list sources)
        ~libs:(Libs.of_list libs)
        ?findlibs
        ?dest
        name

let documentation ?(sources = []) ?findlibs name =
    Package.documentation
        ~sources:(Sources.of_list sources)
        ?findlibs
        name

let builder_of_packaged_product (product : Package.product) : make_builder =
    match product with
        | `library l -> (new library_builder l :> make_builder)
        | `executable e -> (new executable_builder e :> make_builder)
        | `toplevel t -> (new toplevel_builder t :> make_builder)
        | `documentation d -> (new documentation_builder d :> make_builder)
        | `script s -> (new script_builder s :> make_builder)




open Package
class global_builder package =
    let sub_builders = List.map builder_of_packaged_product package.products in
    let global_pattern_targets = [
	    ("%.ml", "%.mll", "ocamllex $(OCAMLLEX_FLAGS) $<");
	    ("%.ml", "%.mly", "ocamlyacc $(OCAMLYACC_FLAGS) $<");
	    ("%.mli", "%.mly", "ocamlyacc $(OCAMLYACC_FLAGS) $<");
	    ("%.cmi", "%.mli", "$(COMPILE) -o $@ $<");
	    ("%.cmi", "%.ml", "$(COMPILE) -o $@ $<");
	    ("%.cmo", "%.ml", "$(COMPILE) -o $@ $<");
	    ("%.cmx", "%.ml", "$(COMPILE_OPT) -o $@ $<");
	    ("%.o", "%.c", "gcc -fPIC $(CFLAGS) -DNATIVE_CODE -I`ocamlc -where` -c -o $@ $<");
    ]
    in
object(self)

    method globals (which : global_target) =
        match which with
            | `dep ->
		          (Sources.all package.sources)
                  @
		          (List.flatten (List.map
                                     (fun x -> (x # globals `dep))
                                     sub_builders))

            | _ -> failwith "global builder does not answer globals queries other than `dep"

    method vars =
        let cmdlinetool_vars cmdline =
            List.map
                (fun (prefix, tool) -> (prefix ^ "FLAGS"), join (CmdLineTools.flags cmdline tool))
                [
                    "OCAMLC_", `ocamlc;
                    "OCAMLOPT_", `ocamlopt;
                    "OCAMLMKTOP_", `ocamlmktop;
                    "OCAMLYACC_", `ocamlyacc;
                    "OCAMLLEX_", `ocamllex;
                    "C", `cc;
                    "OCAMLMKLIB", `ocamlmklib;
                    "OCAMLDOC", `ocamldoc;
                ]
        in


        let product_findlib_files = List.flatten (List.map
                                                      (fun builder -> builder # globals `findlib)
                                                      sub_builders)
        in

        [

	        (* installation info *)
	        "PACKAGE", package.package;
            "FINDLIB_PACKAGE", package.findlib_package;
            "DESTDIR", package.destdir;
	        "PREFIX", package.prefix;

            (* These are shorthand *)
            "PREFIX_DESTDIR", "$(DESTDIR)$(PREFIX)";
	        "FINDLIB_FILES", join (package.findlib_installed_files @ product_findlib_files);

	        (* file info *)
	        "SOURCES", join (Sources.get package.sources [`ml; `mli; `mly; `mll; `c]);
	        "OBJECTS", join (Sources.get package.sources [`cmo]);
            "INTERFACES", join (Sources.get package.sources [`cmi]);
	        "OPT_OBJECTS", join (Sources.get package.sources [`cmx]);
	        "O_OBJECTS", join (Sources.get package.sources [`o]);
	        "LIBS", join package.libs.Libs.cma;
	        "OPT_LIBS", join package.libs.Libs.cmxa;

            "FINDLIBS",
            if package.findlibs = []
            then ""
            else sprintf "-package '%s'" (join package.findlibs);

            "INCLUDES",
            if package.includes <> [] then "-I " ^ (join ~delim:" -I " package.includes) else "";

	        (* variables so I don't have to type so much *)
	        "COMPILE", "ocamlfind ocamlc $(FINDLIBS) -c $(OCAMLC_FLAGS) $(INCLUDES) ";
	        "COMPILE_OPT", "ocamlfind ocamlopt $(FINDLIBS) -c $(OCAMLOPT_FLAGS) $(INCLUDES) ";
	        "LINK", "ocamlfind ocamlc -linkpkg $(FINDLIBS) $(OCAMLC_FLAGS) $(INCLUDES) $(LIBS)";
	        "LINK_OPT", "ocamlfind ocamlopt -linkpkg $(FINDLIBS) $(OCAMLOPT_FLAGS) $(INCLUDES) $(OPT_LIBS)";
	        "MKTOP", "ocamlfind ocamlmktop -linkpkg $(FINDLIBS) $(OCAMLMKTOP_FLAGS) $(INCLUDES) $(LIBS)";
            "DOC", "ocamlfind ocamldoc $(FINDLIBS) $(INCLUDES)";

            (* ocamlmklib isn't sufficiently cross-platform *)
	        "LINKLIB", "ocamlfind ocamlc -linkpkg $(FINDLIBS) -a $(OCAMLC_FLAGS) $(INCLUDES) $(LIBS)";
	        "LINKLIB_OPT", "ocamlfind ocamlopt $(FINDLIBS) -a $(OCAMLOPT_FLAGS) $(INCLUDES)";
            "LINKLIB_SHARED", "gcc -shared -fPIC $(CFLAGS)";
            "LINKLIB_STATIC", "ar rc";
	        "YACC", "ocamlyacc $(OCAMLYACC_FLAGS) $(INCLUDES)";
	        "LEX", "ocamllex $(OCAMLLEX_FLAGS) $(INCLUDES)";
	    ]
        @
        (cmdlinetool_vars package.command_line)
        @
        (List.flatten (List.map (fun builder -> builder # vars) sub_builders))

    method distrib_rules =
        let distrib_rule label target flag extension =
		    let filename = Printf.sprintf "%s.tar%s" label extension in
            let exclusions =
                (String.concat " "
                     (List.map (fun s -> sprintf "--exclude='%s'" s)
                          [ "*~";
                            "CVS";
                            "_darcs";
                            ".arch*";
                            "*/" ^ label;
                            filename ]))
            in
		    let tarflags = exclusions ^ " " ^ flag in

		    (target,
             "",
		     Printf.sprintf "$(MAKE) distclean && ln -s . %s && tar %s -chvf %s %s && rm %s"
			     label tarflags filename label label)
        in
	    let label = package.package ^ "-" ^ package.version in

	    List.map
            (fun (target, flag, extension) -> distrib_rule label target flag extension)
		    [
                ("gzip", "-z", ".gz");
                ("bzip2", "-j", ".bz2");
                ("tar", "", "")
            ]

    method append_ocamldep outchannel =
	    let all_sources = self # globals `dep in

	    let inchannel = Unix.open_process_in
		                    (sprintf "ocamldep %s %s"

			                     (if package.includes <> []
                                  then "-I " ^ (join ~delim:" -I " package.includes)
                                  else "")

			                     (join all_sources))

	    in
        (try
	         while true do
                 fprintf outchannel "%s\n" (input_line inchannel)
	         done
         with End_of_file -> ());

	    close_in inchannel




    method rules =
        let lexer_rule file = (new_ext file ".ml"), file, "" in

        (* TODO: make the Makefile depend on the .mly and .mll files, so it'll be
           re-created when they change - and then run yacc and lex at configure time *)
        let parser_rules file =
            [
	            (new_ext file ".cmo"), (new_ext file ".cmi"), "";
	            (new_ext file ".cmx"), (new_ext file ".cmi"), ""
            ]
        in

        let precompile_rules sources =
	        (List.map lexer_rule (Sources.get sources [`mll]))
            @
	        (List.flatten (List.map parser_rules (Sources.get sources [`mly])))
        in

        let get_all_globals global_tag =
            join (List.flatten (List.map
                                    (fun builder -> builder # globals global_tag)
                                    sub_builders))
        in

        (List.map (fun (name, tag) -> name, get_all_globals tag, "")
             [
		         ("all", `all);
                 ("byte", `byte);
		         ("opt", `opt);
		         ("doc", `doc);
             ])
        @
        [
            ("install",
             "install-findlib " ^ (get_all_globals `install),
             "");

            ("uninstall", "uninstall-findlib " ^ (get_all_globals `uninstall), "");
            ("reinstall", "uninstall", "$(MAKE) install");
            ("install-opt", get_all_globals `install_opt, "");
		    ("clean", "", "rm -rf $(OBJECTS) $(INTERFACES) $(O_OBJECTS) $(OPT_OBJECTS) "
                 ^ (get_all_globals `clean)
                 ^ " " ^ (join package.cleaned)
            );
		    ("distclean", "", "$(MAKE) clean && rm -f Makefile");

            if (get_all_globals `findlib) = "" then
                ("install-findlib", "", "")
            else
                ("install-findlib",
                 "$(FINDLIB_FILES)",
                 "ocamlfind install $(FINDLIB_PACKAGE) META $(FINDLIB_FILES)");

            ("uninstall-findlib",
             "",
             "ocamlfind remove $(FINDLIB_PACKAGE)");
	    ]
        @
        (List.flatten (List.map (fun builder -> builder # rules) sub_builders))
        @
        global_pattern_targets
        @
        (precompile_rules package.sources)
        @
        (self # distrib_rules)


end

let package
    ?(package = "my_program")
	?(version = "0.0")
    ?(destdir = "")
	?(prefix = "/usr/local")
	?(sources = [])
	?(findlibs = [])
	?(libs = [])
	?(includes = [])
    ?(findlib_package = package)
	?(findlib_installed_files = [])
	?(findlib_installs_opt = true)
	?(flags = [])
    ?(cleaned = [])
	?(debug = false)
	products =

    Package.create
        ~sources:(Sources.of_list sources)
        ~libs:(Libs.of_list libs)
        ~command_line:(CmdLineTools.map_of_list flags)
        ~package
        ~version
        ~destdir
        ~prefix
        ~findlibs
        ~includes
        ~findlib_package
        ~findlib_installed_files
        ~findlib_installs_opt
        ~cleaned
        ~debug
        products

let output_makefile ?(filename = "Makefile") package =

	(* * * Makefile * * *)
	let channel = if package.debug then stdout else open_out filename in

    let p = new global_builder package in

	Makefile.render
        ~channel
        p # vars
        p # rules;

    p # append_ocamldep channel;

	if not package.debug then close_out channel


let	output
	?package:pack
	?version
    ?destdir
	?prefix
	?sources
	?findlibs
	?libs
	?includes
    ?findlib_package
	?findlib_installed_files
	?findlib_installs_opt
	?flags
    ?cleaned
	?debug
	targets
    =

    output_makefile (package
                         ?sources ?libs ?flags ?package:pack ?version ?destdir ?prefix ?findlibs ?includes
                         ?findlib_package ?findlib_installed_files ?findlib_installs_opt ?cleaned ?debug
                         targets)

let output_ebuild ?filename package = ()
let output_meta ?(filename = "META") package = ()
let output_omakefile ?(filename = "OMakeFile") package = ()




(***************************************************************************************)
end
module Conf : sig
(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)


(*
	This should look a lot like an arg_spec from Arg.
	The types I can think of autoconf using are String,
	StringList of <separator>, Toggle

	Each entry is (<flag>, <kind>, <defaultvalue>, <description>)

	For my purposes, I'll omit the full autoconf suite of directory control, but the
	following will be built in to configure:

	--prefix, String, "/usr/local", "The prefix under which non-findlib programs will be installed."
	--xxxflags, where xxx is one of the tools we know about.  This will be dumped right into the makefile.

	--rename, StringList of ",", [], "A comma-separated list to be taken two words at a time as substitutions on the
											names of installed programs, so you can rename them to whatever you want."
	--regexp, String, "", "Like rename only cooler"

	All user supplied thingies will be prefixed by '--' and lowercased.  You can also dump your configuration to a .ml
	file and add it to your sources, which kind of rules.

	For each item, it will make a publicly accesible variable:

	StringList will be a list of strings, String will be a string, toggle will be a bool

*)

(**
    A module for build-time configuration.

    Things it can do at build time:
    {ol
        {- Check that certain findlib packages are installed, and where.}
        {- Search for a file from a list of possibilities, for crude trial-and-error location.}
        {- Process user parameters for the build.}}

    It handles the command line parameters for all of the above, and returns a [Conf.t] - or configuration.

    A configuration is a [string] to [value] mapping.  It is generated by the [Conf.configure] function
    from a [configuration_item list].  Each item, in order, is passed the current configuration, and
    returns a potentially modified configuration.
*)

(** The types of values that the configuration tracks *)
type value =
	| StringList of string list	(** A space separated string must be passed by the user. *)
	| String of string
	| Bool of bool

(** The type of configurations *)
type t
type key = string
type doc = string

(** A configuration item represents one build-time check that will be performed.
    This type will be made private in future versions of ocamlconf. *)
type configuration_item =
	| FindLib of key * (string option) * (string option)
	| Path of key * doc * (string list)
	| Param of key * value * doc
	| Custom of (t -> t)


(** A fairly standard configuration.  In most cases you should append your
    configuration items onto the end of this list, as contains a few
    universal parameters that are nice.  In the future it will be
    augmented to supply all the useful defaults that one expects from
    autoconf *)
val standard_spec : (configuration_item * bool) list

(** {4 Configuration Items} *)

(**
    [findlib_check name] checks that a findlib package called [name]
    exists.  If [min] or [max] are specified, then it ensures the package
    has a version within those constraints.
*)
val findlib_check : ?min:string -> ?max:string -> string -> configuration_item

(**
    [path_search name doc paths] performs a rudimentary search through the list of
    paths.  This provides a method for locating libraries that don't have any
    other way to be found.
*)
val path_search : ?doc:string -> string -> string list -> configuration_item

(**
    [param name defaultvalue] provides a compile-time parameter that can be overridden
    by the user.  The default value is mandatory so that ocamlconf knows what type the user
    should be supplying.
*)
val param : ?doc:string -> string -> value -> configuration_item

(**
    [custom f] allows you to have a totally custom configuration function that takes in the
    configuration so far, and returns a possibly modified configuration.  You only need to use this
    if other configuration items depend on the results, otherwise you can just program you custom
    stuff into your configure.ml
*)
val custom : (t -> t) -> configuration_item


(** {4 Configuration Function} *)

(**
    Takes a [configuration_item list], supplemented with a bool to
    say whether to show each item to the user, and returns the
    configuration that results from all the tests are command-line
    parameters.

    At this stage, the command line will be parsed and help output will
    be provided to users who request it, using the documentation strings
    you may or may not have provided when creating configuration items.
*)
val configure : (configuration_item * bool) list -> t


(** {4 Accessing the generated configuration} *)

val conf_value : t -> string -> value

(** This, and the next couple functions, are just wrappers around the [value] variant
  type, to save you a couple lines of code - keeping the configure.ml small is key *)
val conf_stringlist : t -> string -> string list
val conf_string : t -> string -> string
val conf_bool : t -> string -> bool


(** {4 Outping / Informing the User} *)

(** Outputs your completed config into a string, which is valid
	ML and can be used by your program *)
val output_config_file : t -> string -> unit

(** Returns a human readable version of the configuration *)
val summarize_config : t -> (configuration_item * bool) list -> string

end
= struct
(*
  This file is part of ocamlconf - An O'Caml build tool
  Copyright (C) 2003 Kenneth Knowles

  ocamlconf is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  ocamlconf is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ocamlconf; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*)


(*
	This should look a lot like an arg_spec from Arg.
	The types I can think of autoconf using are String,
	StringList of <separator>, Toggle

	Each entry is (<flag>, <kind>, <defaultvalue>, <description>)

	For my purposes, I'll omit the full autoconf suite of directory control, but the
	following will be built in to configure:

	--prefix, String, "/usr/local", "The prefix under which non-findlib programs will be installed."
	--xxxflags, where xxx is one of the tools we know about.  This will be dumped right into the makefile.

	--rename, StringList of ",", [], "A comma-separated list to be taken two words at a time as substitutions on the
											names of installed programs, so you can rename them to whatever you want."
	--regexp, String, "", "Like rename only cooler"

	All user supplied thingies will be prefixed by '--' and lowercased.  You can also dump your configuration to a .ml
	file and add it to your sources, which kind of rules.

	For each item, it will make a publicly accesible variable:

	StringList will be a list of strings, String will be a string, toggle will be a bool

*)

module StringMap = Map.Make(String)
open Printf

type value =
	| StringList of string list
	| String of string
	| Bool of bool
type key = string
type doc = string

type t = value StringMap.t

type configuration_item =
    | FindLib of key * (string option) * (string option)
    | Path of key * doc * (string list)
    | Param of key * value * doc
    | Custom of (t -> t)


let findlib_check ?min ?max name =
    FindLib (name, min, max)

let path_search ?(doc = "") name paths =
    Path (name, doc, paths)

let param ?(doc = "") name value =
    Param (name, value, doc)

let custom f =
    Custom f

exception Incorrect_type of string

(* possibly more to come *)
let standard_spec = [
	Custom (fun conf -> StringMap.add
				"ocaml_path"
				(String (Util.shell_capture "ocamlfind ocamlc -where"))
				conf), false;

	Param ("prefix",
		   String "/usr/local",
		   "The installation prefix, for items not installed via findlib."),	true;
]

exception Configuration_failure of string
exception Incorrect_version of string * string * string option * string option
exception Package_not_found of string * (string list)


module Versions = struct

	let rec compare list1 list2 =
		match list1, list2 with
		| [], [] -> 0
		| _, [] -> 1
		| [], _ -> -1
		| first1 :: rest1, first2 :: rest2 ->
			let result = Pervasives.compare first1 first2 in
			if result = 0 then
				compare rest1 rest2
			else
				result

	let possibly_compare ~actual ~desired =
		match desired with
		| None -> 0
		| Some v ->
			let reg = Str.regexp "\\." in
			compare (Str.split reg actual) (Str.split reg v)
end

module OcamlFind = struct

	let query formatstring key =
		Util.shell_capture (sprintf "ocamlfind query -format \"%s\" %s" formatstring key)

	let version = query "%v"
	let path = query "%d"
end

module Paths = struct
	let rec search paths =
		match paths with
		| [] -> raise Not_found
		| first :: rest ->
			if Sys.file_exists first then
				first
			else
				search rest
end


let dispatch_configuration_item configuration item =
	match item with
	| FindLib (key, minversion, maxversion) ->
		Printf.printf "Checking ocamlfind %s... " key; flush stdout;
		let ver = OcamlFind.version key in
		if	(0 > Versions.possibly_compare ver minversion) ||
			(0 < Versions.possibly_compare ver maxversion) then
			raise (Incorrect_version (key, ver, minversion, maxversion))
		else
			(Printf.printf "found %s\n" ver; flush stdout;
			StringMap.add (key ^ "_path") (String (OcamlFind.path key))
				(StringMap.add (key ^ "_version") (String ver) configuration))

	| Path (key, doc, paths) ->
		printf "Checking path to %s... " key;
		(try
			match StringMap.find (key ^ "_path") configuration with
			| String user_supplied ->
				if Sys.file_exists user_supplied then
					(printf "user supplied %s\n" user_supplied; flush stdout;
					configuration)
				else
					raise (Package_not_found (key, [user_supplied]))
			| _ ->
				raise Not_found
		with
			Not_found ->
				try
					let path = Paths.search paths in
					printf "%s\n" path; flush stdout;
					StringMap.add (key ^ "_path") (String path) configuration
				with
					Not_found -> raise (Package_not_found (key, paths)))

	| Param (key, value, doc) -> configuration (* Nothing to check! *)

	| Custom func -> func configuration (* User-supplied checking *)

let rec dispatch_conf_items configuration conf_items =
	match conf_items with
	| [] -> configuration
	| (first, _) :: rest ->
		dispatch_conf_items (dispatch_configuration_item configuration first) rest


let yes_no_default defvalue newvalue =
	match String.lowercase newvalue with
	| "true" | "t" | "yes" -> true
	| "false" | "f" | "no" | "off" -> false
	| _ -> defvalue (* This is a safe catch - it remains the default value *)

let new_param_value oldvalue newvalue =
	match oldvalue with
	| String s -> String newvalue
	| Bool b -> Bool (yes_no_default b newvalue)
	| StringList _ -> StringList (Str.split (Str.regexp "[ \t]+") newvalue)

(* Arg is unfortunately quite imperative, so we use a reference *)
let argspec_of_conf_item config_ref (conf_item, show_to_user) =
	if show_to_user then
		match conf_item with
		| Param (key, oldval, doc) -> [
				"--" ^ key,
				Arg.String (fun x -> config_ref := StringMap.add
														key
														(new_param_value oldval x)
														!config_ref),
				doc
			]

		| Path (key, doc, _) -> [
				"--" ^ key ^ "-path",
				Arg.String (fun x -> config_ref := StringMap.add (key ^ "_path") (String x) !config_ref),
				doc
			]

		| _ -> []
	else
		[]

let add_default map (item, _) =
	match item with
	| Param (key, default, _) -> StringMap.add key default map
	| _ -> map

(* The user-visible function *)
let configure conf_items =

	(* Create a configuration full of the default values for params *)
	let config_ref = ref (List.fold_left
							add_default
							StringMap.empty
							conf_items)
	in

	Arg.parse
		(List.flatten (List.map (argspec_of_conf_item config_ref) conf_items))
		(fun s -> Printf.eprintf "[WARNING] Ignoring anonymous argument '%s'\n%!" s)
		"./configure [options ...]";


	try
		dispatch_conf_items !config_ref conf_items
	with
		| Configuration_failure message ->
			printf "\nConfiguration failed: %s\n" message;
			exit 1

		| Incorrect_version (key, actualver, minver, maxver) ->
			printf "\nIncorrect version of %s: %s\n" key actualver;
			(match minver with Some v -> printf "Minimum version: %s\n" v | _ -> ());
			(match maxver with Some v -> printf "Maximum version: %s\n" v | _ -> ());
			exit 1

		| Package_not_found (key, paths) ->
			printf "\nCould not find %s: tried %s\n" key (String.concat ", " paths);
			exit 1
;;




(* Functions for extracting the contents of the configuration *)

let conf_value conf name = StringMap.find name conf

let conf_stringlist conf name =
	match conf_value conf name with
	| StringList sl -> sl
	| _ -> raise (Incorrect_type name)

let conf_string conf name =
	match conf_value conf name with
	| String s -> s
	| _ -> raise (Incorrect_type name)

let conf_bool conf name =
	match conf_value conf name with
	| Bool b -> b
	| _ -> raise (Incorrect_type name)

let output_config_file conf filename =
	let outchan = open_out filename in

	StringMap.iter
		(fun name value ->
			match value with
			| Bool b -> fprintf outchan "let %s = %B" name b
			| String s -> fprintf outchan "let %s = \"%s\"" name s
			| StringList sl -> fprintf outchan "let %s = [\"%s\"]" name (String.concat "\"; \"" sl)
			)
		conf;
	close_out outchan
;;

let rec summarize_config_rec ?(so_far = "") conf conf_items =
	match conf_items with
	| [] -> so_far
	| (conf_item, true) :: rest ->
		let description =
			match conf_item with
			| FindLib (key, _, _) ->
				(sprintf "%s path: %s\n" key (conf_string conf (key ^ "_path"))) ^
				(sprintf "%s version: %s\n" key (conf_string conf (key ^ "_version")))

			| Path (key, doc, _) ->
				(sprintf "%s path: %s\n" key (conf_string conf (key ^ "_path")))

			| Param (key, value, doc) ->
				sprintf "%s: %s\n" key
					(match (conf_value conf key) with
					| Bool b -> string_of_bool b
					| String s -> s
					| StringList sl -> String.concat " " sl)

			| _ -> ""
		in
		summarize_config_rec ~so_far:(so_far ^ description) conf rest

	| _ :: rest ->
		summarize_config_rec ~so_far conf rest

let summarize_config conf conf_items = summarize_config_rec conf conf_items

;;


end
open Conf;;
open Printf;;
open Util;;

let spec =
  (standard_spec @
     [
       param "freetds-libdir" (String "")
         ~doc:"Path to the freetds library.", true;
       param   "freetds-incdir" (String "")
         ~doc:"Path to the freetds include files.", true;
       findlib_check "str", true;
     ])
;;

let configuration = configure spec

open AutoMake;;

(* Inform the user of the configuration *)
let _ =
	printf "
----------- Configuration Summary -----------
";
	print_string (summarize_config configuration spec);
	print_string "If the tds paths are blank, its ok.  Just 'make' and 'make install'.\n"

let sources = ["ct_c.c"; "ct.mli"; "ct.ml"]
let c_libflag = match conf_string configuration "freetds-libdir" with "" -> "" | s -> "-L" ^ s
let c_incflag = match conf_string configuration "freetds-incdir" with "" -> "" | s -> "-I" ^ s

let libflag = "" (*match conf_string configuration "freetds-libdir" with "" -> "" | s -> "-L " ^ s*)
let incflag = "" (*match conf_string configuration "freetds-incdir" with "" -> "" | s -> "-I " ^ s*)

let ml_libflag = match conf_string configuration "freetds-libdir" with
    "" -> ""
    | s -> sprintf "-dllpath %s -ccopt -L%s" s s

let freetds_top = toplevel "freetds.top" ~dest:`nowhere ~sources
let freetds_cma = library "freetds" ~dest:`findlib ~shared:true ~sources
let freetds_doc = documentation "docs" ~sources

(* The makefile generation information *)
let _ = output
	~package:"ocaml-freetds"

    ~findlib_package:"freetds"

	~version:"0.2"

    ~findlib_installs_opt:false

    ~findlib_installed_files:["ct.cmi"; "ct.mli"]

	~findlibs:["str"]

	~flags:[
		(`ocamldoc, "-I ml -colorize-code -sort -keep-code");
		(`ocamlc, sprintf "-g %s -cclib -lct" ml_libflag);
		(`ocamlopt, sprintf "-cclib %s -lct -ccopt -L." ml_libflag);
		(`ocamlmktop, sprintf "-custom -g %s -cclib -lct" ml_libflag);
        (`cc, sprintf "%s %s -lct" c_incflag c_libflag);
	]

    ~cleaned:["*~"; "*/*~"]

	[
        freetds_cma;
        freetds_doc;
        freetds_top;

    (* In order to use these, just feed the .ml files to the toplevel -
        I have yet to perfect ocamlconf's shared library paths; I don't really
        want to force the executables to have "." in their built in library path *)
	]
;;








